包正;入("math/rand";"sync/atomic")
种readOp构{key整;resp通整}
种writeOp构{key整;val整;resp通双}
功正(){
    变ops整64=0
    reads:=造(通*readOp)
    writes:=造(通*writeOp)
    去功(){
        变state=造(图[整]整)
        为{选{事read:=<-reads:read.resp<-state[read.key]
              事write:=<-writes:state[write.key]=write.val;write.resp<-真
             }}}()
    为r:=0;r<100;r++{
        去功(){
            为{read:=&readOp{key:rand.Intn(5),resp:造(通整)}
               reads<-read
               <-read.resp
               atomic.AddInt64(&ops,1)
              }}()}
    为w:=0;w<10;w++{
        去功(){
            为{write:=&writeOp{key:rand.Intn(5),val:rand.Intn(100),resp:造(通双)}
               writes<-write
               <-write.resp
               atomic.AddInt64(&ops,1)
              }}()}
    时Sleep(时Second)
    opsFinal:=atomic.LoadInt64(&ops)
    形Println("ops:",opsFinal)

    让range:="abc" //when used with 让, Go keywords like "range" can be used as identifiers
    让range="abcdefg"
	形Printf("range: %v\n",range)
}
